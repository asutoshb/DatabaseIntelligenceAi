# Chunk 6: Query Execution Service - Detailed Explanation

## üéØ What We Built

We built a **safe SQL query execution service** that can execute generated SQL queries against user databases with security, error handling, and result processing.

---

## üìö Key Concepts Explained

### 1. **JDBC (Java Database Connectivity)**

**What is JDBC?**
- JDBC = Java Database Connectivity
- Standard Java API for connecting to databases
- Allows Java programs to execute SQL queries directly
- Works with any database (PostgreSQL, MySQL, Oracle, etc.)

**Simple Explanation:**
- **JPA** (Chunk 2) = High-level, automatic (Spring manages everything)
- **JDBC** (Chunk 6) = Low-level, manual (you control everything)

**Why Use JDBC Here?**
- We need to execute **dynamic SQL** (generated by AI)
- We need to connect to **user databases** (not our own database)
- We need **read-only** connections (security)
- We need **timeout control** (prevent long-running queries)

**Example:**

```java
// Step 1: Create connection
String url = "jdbc:postgresql://localhost:5432/mydb";
Connection conn = DriverManager.getConnection(url, "user", "password");

// Step 2: Execute query
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM customers");

// Step 3: Process results
while (rs.next()) {
    String name = rs.getString("name");
    System.out.println(name);
}

// Step 4: Close resources
rs.close();
stmt.close();
conn.close();
```

---

### 2. **Connection Management**

**What is Connection Management?**
- Creating and closing database connections efficiently
- Connections are expensive (network resources)
- Must always close connections (prevent leaks!)

**Why Important?**
- **Connection Leaks:** If you don't close connections, database runs out!
- **Performance:** Reusing connections is faster
- **Security:** Each query should use isolated connection

**Our Approach:**
```java
Connection connection = null;
try {
    connection = createConnection(databaseInfo);
    // Use connection
} finally {
    // ALWAYS close in finally block!
    if (connection != null) {
        connection.close();
    }
}
```

**Best Practices:**
- ‚úÖ Always close connections in `finally` block
- ‚úÖ Use read-only connections for queries
- ‚úÖ Set connection timeout
- ‚úÖ Handle exceptions gracefully

---

### 3. **Read-Only Connections**

**What is Read-Only?**
- Connection that can only read data, not modify it
- Security feature to prevent accidental data changes

**Why Important?**
- **Safety:** Even if SQL is wrong, can't delete data
- **Security:** Prevents malicious SQL from modifying data
- **Best Practice:** For query-only operations

**How We Implement:**

```java
// Create connection
Connection conn = DriverManager.getConnection(url, props);

// Set read-only mode
conn.setReadOnly(true);  // ‚Üê Can't modify data!

// Additional safety
props.setProperty("readOnly", "true");
```

**What This Prevents:**
- ‚ùå `UPDATE customers SET name = 'Hacked'`
- ‚ùå `DELETE FROM customers`
- ‚ùå `DROP TABLE customers`
- ‚úÖ `SELECT * FROM customers` (only this works!)

---

### 4. **Query Timeout**

**What is Query Timeout?**
- Maximum time a query can run
- Automatically cancels query if it takes too long

**Why Important?**
- **Resource Protection:** Prevents long-running queries from consuming resources
- **User Experience:** Users don't wait forever
- **Security:** Prevents denial-of-service attacks

**How We Implement:**

```java
Statement stmt = connection.createStatement();
stmt.setQueryTimeout(30);  // 30 seconds max

// If query takes > 30 seconds, throws SQLTimeoutException
ResultSet rs = stmt.executeQuery(sql);
```

**Example:**
```
Query: "SELECT * FROM huge_table WHERE complex_condition"
Timeout: 30 seconds

If query takes 45 seconds:
‚Üí SQLTimeoutException thrown
‚Üí Connection closed
‚Üí Resources freed
‚Üí User gets error message
```

---

### 5. **ResultSet Processing**

**What is ResultSet?**
- Object that contains query results
- Like a cursor that moves through rows
- Provides methods to read column values

**How It Works:**

```java
ResultSet rs = stmt.executeQuery("SELECT id, name, email FROM users");

// rs.next() moves to next row, returns false when done
while (rs.next()) {
    // Get column values by name or index
    Long id = rs.getLong("id");           // Column name
    String name = rs.getString("name");   // Column name
    String email = rs.getString(3);       // Column index (1-based)
}
```

**Converting to JSON:**

```java
List<Map<String, Object>> rows = new ArrayList<>();

while (resultSet.next()) {
    Map<String, Object> row = new HashMap<>();
    
    // Get all columns
    for (int i = 1; i <= columnCount; i++) {
        String columnName = metaData.getColumnName(i);
        Object value = resultSet.getObject(i);
        row.put(columnName, value);
    }
    
    rows.add(row);
}

// Result: [{ "id": 1, "name": "John" }, { "id": 2, "name": "Jane" }]
```

---

### 6. **SQL Validation (Reusing from Chunk 5)**

**Why Validate Again?**
- Double-check security before execution
- Even though we generate SQL, we validate again
- Defense in depth (multiple layers of security)

**What We Check:**
- ‚úÖ Only SELECT queries
- ‚úÖ No dangerous keywords (DROP, DELETE, etc.)
- ‚úÖ No SQL injection patterns
- ‚úÖ Balanced parentheses

**Example:**

```java
// ‚úÖ Valid - will execute
"SELECT * FROM customers LIMIT 5"

// ‚ùå Invalid - blocked before execution
"DROP TABLE customers"  // Dangerous keyword
"UPDATE customers..."   // Not SELECT
```

---

## üèóÔ∏è Architecture Overview

### Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Generated SQL       ‚îÇ
‚îÇ "SELECT * FROM..."   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ QueryExecution      ‚îÇ  ‚Üê REST API endpoint
‚îÇ Controller          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SQL Validator       ‚îÇ  ‚Üê Validate SQL (SELECT only)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ DatabaseInfo        ‚îÇ  ‚Üê Get connection info
‚îÇ Repository          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ QueryExecution      ‚îÇ  ‚Üê Execute query
‚îÇ Service             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îú‚îÄ‚îÄ‚îÄ‚ñ∫ Create JDBC Connection (read-only)
           ‚îú‚îÄ‚îÄ‚îÄ‚ñ∫ Set Query Timeout
           ‚îú‚îÄ‚îÄ‚îÄ‚ñ∫ Execute SQL
           ‚îú‚îÄ‚îÄ‚îÄ‚ñ∫ Process ResultSet
           ‚îî‚îÄ‚îÄ‚îÄ‚ñ∫ Close Resources
           ‚îÇ
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ JSON Response       ‚îÇ
‚îÇ { rows: [...], ... }‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîÑ Complete Flow (Step by Step)

### Step 1: User Requests Query Execution

```
POST /api/query-execution/execute
{
  "databaseInfoId": 1,
  "sqlQuery": "SELECT * FROM customers LIMIT 5",
  "timeoutSeconds": 30
}
```

### Step 2: Controller Receives Request

```java
@PostMapping("/execute")
public ResponseEntity<QueryExecutionResponse> executeQuery(
    @RequestBody QueryExecutionRequest request
) {
    // Call service
}
```

### Step 3: Service Validates SQL

```java
SQLValidator.ValidationResult validation = sqlValidator.validate(sqlQuery);
if (!validation.isValid()) {
    return errorResponse("SQL validation failed");
}
```

### Step 4: Get Database Connection Info

```java
DatabaseInfo dbInfo = databaseInfoRepository.findById(databaseInfoId);
// dbInfo contains: host, port, databaseName, username, password
```

### Step 5: Create JDBC Connection

```java
String url = "jdbc:postgresql://localhost:5432/mydb";
Connection conn = DriverManager.getConnection(url, "user", "password");
conn.setReadOnly(true);  // Security!
```

### Step 6: Execute Query with Timeout

```java
Statement stmt = conn.createStatement();
stmt.setQueryTimeout(30);  // 30 seconds max
ResultSet rs = stmt.executeQuery(sqlQuery);
```

### Step 7: Process Results

```java
List<Map<String, Object>> rows = new ArrayList<>();
while (rs.next()) {
    Map<String, Object> row = new HashMap<>();
    // Read each column
    row.put("id", rs.getLong("id"));
    row.put("name", rs.getString("name"));
    rows.add(row);
}
```

### Step 8: Build Response

```java
QueryExecutionResponse response = new QueryExecutionResponse();
response.setSuccess(true);
response.setRows(rows);
response.setColumns(columnNames);
response.setRowCount(rows.size());
response.setExecutionTimeMs(endTime - startTime);
```

### Step 9: Close Resources

```java
finally {
    rs.close();
    stmt.close();
    conn.close();  // Important!
}
```

### Step 10: Return JSON Response

```json
{
  "success": true,
  "rows": [
    { "id": 1, "name": "John" },
    { "id": 2, "name": "Jane" }
  ],
  "columns": ["id", "name"],
  "rowCount": 2,
  "executionTimeMs": 45,
  "executedAt": "2025-11-04T15:30:00"
}
```

---

## üîê Security Features

### 1. **Read-Only Connections**

```java
connection.setReadOnly(true);
```

**Prevents:**
- UPDATE, INSERT, DELETE, DROP operations
- Even if SQL contains these, database rejects them

### 2. **SQL Validation**

```java
sqlValidator.validate(sqlQuery);
```

**Blocks:**
- Dangerous keywords
- SQL injection patterns
- Non-SELECT queries

### 3. **Query Timeout**

```java
statement.setQueryTimeout(30);
```

**Prevents:**
- Long-running queries
- Resource exhaustion
- Denial-of-service attacks

### 4. **Connection Isolation**

- Each query uses separate connection
- No shared state
- Cleanup guaranteed in `finally` block

### 5. **Error Handling**

- No sensitive info exposed
- Generic error messages
- Proper resource cleanup

---

## üéì Key Differences: JPA vs JDBC

### JPA (Chunk 2) - Used for Our Database

```java
// High-level, automatic
User user = userRepository.findById(1L);
// JPA generates SQL, executes it, converts to object
```

**Use When:**
- Working with your own database
- CRUD operations
- Type-safe, automatic

### JDBC (Chunk 6) - Used for User Databases

```java
// Low-level, manual
Connection conn = DriverManager.getConnection(url, user, pass);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM customers");
// You control everything
```

**Use When:**
- Connecting to external databases
- Executing dynamic SQL
- Need fine-grained control

---

## üìä Example: Complete Query Execution

### Input:

```json
{
  "databaseInfoId": 1,
  "sqlQuery": "SELECT id, name, email FROM customers WHERE id < 5",
  "timeoutSeconds": 30
}
```

### Process:

1. **Validate:** ‚úÖ Valid SELECT query
2. **Get DB Info:** Database at `localhost:5432/customers_db`
3. **Connect:** Create read-only connection
4. **Execute:** Run SQL with 30s timeout
5. **Process:** Convert ResultSet to JSON

### Output:

```json
{
  "success": true,
  "rows": [
    { "id": 1, "name": "John", "email": "john@example.com" },
    { "id": 2, "name": "Jane", "email": "jane@example.com" },
    { "id": 3, "name": "Bob", "email": "bob@example.com" },
    { "id": 4, "name": "Alice", "email": "alice@example.com" }
  ],
  "columns": ["id", "name", "email"],
  "rowCount": 4,
  "executionTimeMs": 12,
  "executedAt": "2025-11-04T15:30:00"
}
```

---

## üö® Error Handling

### SQL Validation Error

```json
{
  "success": false,
  "errorMessage": "SQL validation failed: Dangerous SQL keyword detected: DROP",
  "executionTimeMs": 1
}
```

### Connection Error

```json
{
  "success": false,
  "errorMessage": "SQL execution error: Connection refused",
  "executionTimeMs": 5000
}
```

### Timeout Error

```json
{
  "success": false,
  "errorMessage": "Query timeout: Query took longer than 30 seconds",
  "executionTimeMs": 30000
}
```

---

## üîß Technical Details

### Connection URL Format

**PostgreSQL:**
```
jdbc:postgresql://host:port/database
jdbc:postgresql://localhost:5432/mydb
```

**MySQL:**
```
jdbc:mysql://host:port/database?useSSL=false&serverTimezone=UTC
jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC
```

### Type Conversion

**Database Types ‚Üí Java Types:**
- `VARCHAR` ‚Üí `String`
- `INTEGER` ‚Üí `Integer`
- `BIGINT` ‚Üí `Long`
- `DECIMAL` ‚Üí `BigDecimal` ‚Üí `Double` (for JSON)
- `DATE` ‚Üí `java.sql.Date` ‚Üí `String` (for JSON)
- `TIMESTAMP` ‚Üí `java.sql.Timestamp` ‚Üí `String` (for JSON)

---

## ‚úÖ Best Practices

1. **Always Close Resources**
   ```java
   finally {
       if (rs != null) rs.close();
       if (stmt != null) stmt.close();
       if (conn != null) conn.close();
   }
   ```

2. **Use Read-Only Connections**
   ```java
   connection.setReadOnly(true);
   ```

3. **Set Query Timeout**
   ```java
   statement.setQueryTimeout(30);
   ```

4. **Validate SQL Before Execution**
   ```java
   sqlValidator.validate(sqlQuery);
   ```

5. **Handle Exceptions Gracefully**
   ```java
   catch (SQLTimeoutException e) {
       // Handle timeout
   } catch (SQLException e) {
       // Handle SQL error
   }
   ```

---

## üöÄ What's Next?

**Chunk 7:** Authentication & Authorization
- JWT tokens
- User login/registration
- Protected endpoints
- Role-based access

---

**Chunk 6 Complete! Safe SQL query execution is working! üéâ**

